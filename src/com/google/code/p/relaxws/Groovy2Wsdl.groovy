/*
 * Copyright 2008 Jason Sando
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.google.code.p.relaxws

import com.thaiopensource.relaxng.edit.SchemaCollection
import com.thaiopensource.relaxng.input.InputFailedException
import com.thaiopensource.relaxng.input.InputFormat
import com.thaiopensource.relaxng.input.parse.compact.CompactParseInputFormat
import com.thaiopensource.relaxng.output.LocalOutputDirectory
import com.thaiopensource.relaxng.output.OutputDirectory
import com.thaiopensource.relaxng.output.OutputFormat
import com.thaiopensource.relaxng.output.xsd.XsdOutputFormat
import com.thaiopensource.xml.sax.ErrorHandlerImpl
import com.google.code.p.relaxws.parser.RelaxWizParser
import com.google.code.p.relaxws.parser.ASTtypesDecl
import com.google.code.p.relaxws.parser.ASTservice
import com.google.code.p.relaxws.parser.ASTportDecl
import com.google.code.p.relaxws.parser.ASToperationDecl
import com.google.code.p.relaxws.parser.ASTMessageDef

/**
 * The Groovy version of Conver2Wsdl ... this was just to play with Groovy, but I kind of like it now.
 *
 * - Groovy has multiline string literals with embedded groovy expr, making it easy to read the xml templates
 *    (although XML literal support would be nicer)
 * -  
 */
class Groovy2Wsdl {

    private PrintWriter out
    private ASTservice tree

    private static void usage (String reason = null) {
        if (reason)
            System.err.println ("Command failed: $reason")
        System.err.println ('''\
USAGE:

    Convert2Wsdl [-d output-folder] <input.rws>
        ''')
        System.exit (1)
    }

    private static void fail (String reason) {
        if (reason)
            System.err.println ("Command failed: $reason")
        System.exit (1)
    }

    private static String fileBase (String name) {
        int dot = name.lastIndexOf('.')
        dot > 0? name.substring (0, dot): name
    }

    /**
     * Run from command line.
     */
    static void main(args) {

        String outputPath = null
        String inputFilePath = null

        int lastArg = args.length - 1
        for (int i = 0; i < args.length; i++) {
            if ("-d" == args[i] && i < lastArg) {
                outputPath = args[i + 1]
                i++
            } else if (args[i].startsWith("-")) {
                usage("unrecognized option ${args[i]}")
            } else {
                if (inputFilePath) {
                    usage("Multiple input files specified: $inputFilePath, ${args[i]}")
                }
                inputFilePath = args[i]
            }
        }

        if (!inputFilePath) {
            usage()
        }

        File inputFile = new File (inputFilePath)
        if (!inputFile.exists()) {
            fail ("$inputFilePath not found.")
        }
        if (!outputPath) {
            outputPath = inputFile.parent
        }

        File outputFileDir = new File (outputPath)
        if (!outputFileDir.exists()) {
            if (!outputFileDir.mkdirs()) {
                fail ("failed to create output folder $outputPath")
            }
        }

        BufferedReader rdr = new BufferedReader (new FileReader(inputFile))
        RelaxWizParser p = new RelaxWizParser (rdr)
        ASTservice parseTree = p.service ()

        File outputFile = new File(outputFileDir, fileBase(inputFile.name) + '.wsdl')
        System.err.println("Groovy2Wsdl: processing ${inputFile.name} to ${outputFile.path}")

        PrintWriter outputWriter = new PrintWriter(new FileWriter(outputFile))

        Groovy2Wsdl converter = new Groovy2Wsdl(out: outputWriter, tree: parseTree)
        converter.convert()

        outputWriter.close()
    }

    private void convert() throws Exception {

        if (!tree.namespace) {
            tree.namespace = "http://tempuri.org/${tree.name}"
        }
        String ns = tree.namespace

        out.print("""\
<?xml version="1.0"?>
<!--
   : This file generated by Groovy2Wsdl.
-->
<definitions 	name="${tree.name}"
		        targetNamespace="${ns}"
		        xmlns:tns="${ns}"
        		xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
		        xmlns="http://schemas.xmlsoap.org/wsdl/">
	<types>
""")
        // Make a pass through and assign all message names, and build proper rnc block
        Set<String> messageNames = new HashSet<String>()
        StringBuffer rncBuff = new StringBuffer()
        rncBuff.append ("default namespace = \"$ns\"\n")

        for (portNode in tree.children) {
            if (portNode instanceof ASTtypesDecl) {
                rncBuff.append(((ASTtypesDecl) portNode).getRnc())
                continue
            }

            ASTportDecl port = (ASTportDecl) portNode

            // patch up default name if not set.
            if (!port.name) {
                port.name = "${tree.name}Port"
            }

            // enumerate operations in this port
            for (ASToperationDecl op in port.children) {

                // children of op node
                for (ASTMessageDef message in op.children) {
                    message.defaultMessageName = op.name

                    if (messageNames.contains (message.messageName)) {
                        // todo: loop searching for unique name
                        message.messageName = message.messageName + '1'
                    } else {
                        messageNames += message.messageName
                    }

                    if (!message.name) {
                        message.defaultName = op.name
                    }

                    rncBuff.append (message.name + ' = ')
                    rncBuff.append ("element ${message.name} {\n")
                    String s = message.rnc
                    if (s.trim().size() == 0) {
                        s = 'text'
                    }
                    rncBuff.append(s).append('}\n')
                }
            }
        }

        // convert rnc to xsd
        out.print (Groovy2Wsdl.toXsd(rncBuff.toString()))
        out.print ('  </types>\n\n')

        // declare messages for each in and out of each operation for each port (must be unique)
        for (ASTportDecl port in tree.children.findAll {it instanceof ASTportDecl}) {

            // enumerate operations in this port
            for (ASToperationDecl op in port.children) {

                // children of op node
                for (ASTMessageDef message in op.children) {
                    // declare message type
                    out.println("""\
  <message name="${message.messageName}">
    <part name="body" element="tns:${message.name}"/>
  </message>
""")
                }
            }

            out.println()
            out.println("  <portType name=\"${port.name}\">")

            for (ASToperationDecl op in port.children) {
                out.println("    <operation name=\"${op.name}\">")

                // children of op node
                for (ASTMessageDef message in op.children) {
                    switch (message.getType()) {
                        case ASTMessageDef.MessageType.In:
                            out.println("      <input message=\"tns:${message.messageName}\"/>")
                            break

                        case ASTMessageDef.MessageType.Out:
                            out.println("      <output message=\"tns:${message.messageName}\"/>")
                            break

                        case ASTMessageDef.MessageType.Fault:
                            out.println("      <fault message=\"tns:${message.messageName}\"/>")
                            break
                    }
                }

                out.println("    </operation>")
            }
            out.println("  </portType>")

            // binding to soap
            out.println """
  <binding name="${port.name}SoapBinding" type="tns:${port.name}">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
"""

            for (ASToperationDecl op in port.children) {
                out.print """\
    <operation name="${op.name}">
        <soap:operation soapAction="${ns}/${port.name}#${op.name}"/>
        <input>
            <soap:body use="literal"/>
        </input>
        <output>
            <soap:body use="literal"/>
        </output>
        <fault>
            <soap:body use="literal"/>
        </fault>
    </operation>
"""
            }
            out.print """
</binding>

<service name="${tree.name + port.name}Service">
	<port name="${port.name}" binding="tns:${port.name}SoapBinding">
		<soap:address location="http://example.com/${tree.name}"/>
	</port>
</service>
"""
        }
        out.print '</definitions>\n'
    }

    private static String toXsd (String rnc) {

        // write the rnc to a temp file
        File rncInput = File.createTempFile("relaxwiz", ".rnc")
        FileWriter fw = new FileWriter (rncInput)
        fw.write(rnc)
        fw.close()

        // Use Trang to convert to an XSD file
        InputFormat inFormat = new CompactParseInputFormat()
        ErrorHandlerImpl handler = new ErrorHandlerImpl()
        SchemaCollection sc = null

        try {
            sc = inFormat.load(new URL("file", "", rncInput.getAbsolutePath()).toString(),
                                new String[0], "xsd", handler)
        } catch (InputFailedException e) {
            System.err.println("Error in RNC preprocessor, source follows:")
            int line = 0
            rnc.split("\n").each {String s ->
                line++
                System.err.printf("%3d: %s\n", line, s)
            }
            System.exit (1)
        }
        OutputFormat of = new XsdOutputFormat()
        File xsdOutput = File.createTempFile("relaxwiz", ".xsd")
        OutputDirectory od = new LocalOutputDirectory(sc.getMainUri(), xsdOutput, "xsd",
                                                      "UTF-8", 80, 2)
        String[] outParams = [{new URL("file", "", xsdOutput.getAbsolutePath()).toString()}]
        of.output(sc, od, new String[0], "rnc", handler)

        // read in file and return as string.
        StringBuffer buf = new StringBuffer()
        xsdOutput.eachLine {
            if (!it.startsWith("<?xml"))
                buf.append (it).append ('\n')
        }
        return buf.toString()
    }
}

